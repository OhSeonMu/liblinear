!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AR	blas/Makefile	/^AR     ?= ar$/;"	m
B	linear.cpp	/^		double *B, *C, *G;$/;"	m	class:Solver_MCSVM_CS	file:
BLAS_INCLUDE	blas/blas.h	9;"	d
C	linear.cpp	/^		double *B, *C, *G;$/;"	m	class:Solver_MCSVM_CS	file:
C	linear.cpp	/^	double *C;$/;"	m	class:l2r_erm_fun	file:
C	linear.h	/^	double C;$/;"	m	struct:parameter
CC	Makefile	/^CC ?= gcc$/;"	m
CC	matlab/Makefile	/^CC ?= gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -Wconversion -O3 -fPIC$/;"	m
CFLAGS	blas/Makefile	/^CFLAGS = $(OPTFLAGS)$/;"	m
CFLAGS	matlab/Makefile	/^CFLAGS = -Wall -Wconversion -O3 -fPIC -I$(MATLABDIR)\/extern\/include -I..$/;"	m
CMD_LEN	matlab/predict.c	15;"	d	file:
CMD_LEN	matlab/train.c	16;"	d	file:
CXX	Makefile	/^CXX ?= g++$/;"	m
CXX	matlab/Makefile	/^CXX ?= g++$/;"	m
C_times_loss	linear.cpp	/^double l2r_l2_svc_fun::C_times_loss(int i, double wx_i)$/;"	f	class:l2r_l2_svc_fun
C_times_loss	linear.cpp	/^double l2r_l2_svr_fun::C_times_loss(int i, double wx_i)$/;"	f	class:l2r_l2_svr_fun
C_times_loss	linear.cpp	/^double l2r_lr_fun::C_times_loss(int i, double wx_i)$/;"	f	class:l2r_lr_fun
CleanCommand	python/setup.py	/^class CleanCommand(clean_cmd):$/;"	c
D	linear.cpp	/^	double *D;$/;"	m	class:l2r_lr_fun	file:
EXIT_LOAD_MODEL	linear.cpp	3441;"	d	file:
FALSE	blas/blas.h	18;"	d
FFLAGS	blas/Makefile	/^FFLAGS = $(OPTFLAGS)$/;"	m
FILES	blas/Makefile	/^FILES = dnrm2.o daxpy.o ddot.o dscal.o$/;"	m
FSCANF	linear.cpp	3432;"	d	file:
G	linear.cpp	/^		double *B, *C, *G;$/;"	m	class:Solver_MCSVM_CS	file:
GETI	linear.cpp	1102;"	d	file:
GETI	linear.cpp	1103;"	d	file:
GETI	linear.cpp	1310;"	d	file:
GETI	linear.cpp	1311;"	d	file:
GETI	linear.cpp	1473;"	d	file:
GETI	linear.cpp	1474;"	d	file:
GETI	linear.cpp	1777;"	d	file:
GETI	linear.cpp	1778;"	d	file:
GETI	linear.cpp	574;"	d	file:
GETI	linear.cpp	897;"	d	file:
GETI	linear.cpp	898;"	d	file:
HEADERS	blas/Makefile	/^HEADERS = blas.h blasp.h$/;"	m
Hv	linear.cpp	/^void l2r_l2_svc_fun::Hv(double *s, double *Hs)$/;"	f	class:l2r_l2_svc_fun
Hv	linear.cpp	/^void l2r_lr_fun::Hv(double *s, double *Hs)$/;"	f	class:l2r_lr_fun
I	linear.cpp	/^	int *I;$/;"	m	class:l2r_l2_svc_fun	file:
INF	linear.cpp	23;"	d	file:
INF	matlab/train.c	18;"	d	file:
INF	train.c	9;"	d	file:
L1R_L2LOSS_SVC	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L1R_L2LOSS_SVC	python/liblinear/liblinear.py	/^L1R_L2LOSS_SVC = 5$/;"	v
L1R_LR	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L1R_LR	python/liblinear/liblinear.py	/^L1R_LR = 6$/;"	v
L2R_L1LOSS_SVC_DUAL	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L2R_L1LOSS_SVC_DUAL	python/liblinear/liblinear.py	/^L2R_L1LOSS_SVC_DUAL = 3$/;"	v
L2R_L1LOSS_SVR_DUAL	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L2R_L1LOSS_SVR_DUAL	python/liblinear/liblinear.py	/^L2R_L1LOSS_SVR_DUAL = 13$/;"	v
L2R_L2LOSS_SVC	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L2R_L2LOSS_SVC	python/liblinear/liblinear.py	/^L2R_L2LOSS_SVC = 2$/;"	v
L2R_L2LOSS_SVC_DUAL	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L2R_L2LOSS_SVC_DUAL	python/liblinear/liblinear.py	/^L2R_L2LOSS_SVC_DUAL = 1$/;"	v
L2R_L2LOSS_SVR	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L2R_L2LOSS_SVR	python/liblinear/liblinear.py	/^L2R_L2LOSS_SVR = 11$/;"	v
L2R_L2LOSS_SVR_DUAL	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L2R_L2LOSS_SVR_DUAL	python/liblinear/liblinear.py	/^L2R_L2LOSS_SVR_DUAL = 12$/;"	v
L2R_LR	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L2R_LR	python/liblinear/liblinear.py	/^L2R_LR = 0$/;"	v
L2R_LR_DUAL	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
L2R_LR_DUAL	python/liblinear/liblinear.py	/^L2R_LR_DUAL = 7$/;"	v
LIBLINEAR_VERSION	linear.h	4;"	d
LIBS	Makefile	/^LIBS = blas\/blas.a$/;"	m
MATLABDIR	matlab/Makefile	/^MATLABDIR ?= \/usr\/local\/matlab$/;"	m
MAX	blas/blas.h	23;"	d
MCSVM_CS	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
MCSVM_CS	python/liblinear/liblinear.py	/^MCSVM_CS = 4$/;"	v
MEX	matlab/Makefile	/^MEX = $(MATLABDIR)\/bin\/mex$/;"	m
MEX_EXT	matlab/Makefile	/^MEX_EXT = $(shell $(MATLABDIR)\/bin\/mexext)$/;"	m
MEX_OPTION	matlab/Makefile	/^MEX_OPTION = CC="$(CXX)" CXX="$(CXX)" CFLAGS="$(CFLAGS)" CXXFLAGS="$(CFLAGS)"$/;"	m
MIN	blas/blas.h	22;"	d
Malloc	linear.cpp	24;"	d	file:
Malloc	matlab/linear_model_matlab.c	13;"	d	file:
Malloc	matlab/predict.c	17;"	d	file:
Malloc	matlab/train.c	17;"	d	file:
Malloc	train.c	8;"	d	file:
NEWTON	newton.cpp	/^NEWTON::NEWTON(const function *fun_obj, double eps, double eps_cg, int max_iter)$/;"	f	class:NEWTON
NEWTON	newton.h	/^class NEWTON$/;"	c
NUM_OF_RETURN_FIELD	matlab/linear_model_matlab.c	15;"	d	file:
ONECLASS_SVM	linear.h	/^enum { L2R_LR, L2R_L2LOSS_SVC_DUAL, L2R_L2LOSS_SVC, L2R_L1LOSS_SVC_DUAL, MCSVM_CS, L1R_L2LOSS_SVC, L1R_LR, L2R_LR_DUAL, L2R_L2LOSS_SVR = 11, L2R_L2LOSS_SVR_DUAL, L2R_L1LOSS_SVR_DUAL, ONECLASS_SVM = 21 }; \/* solver_type *\/$/;"	e	enum:__anon1
ONECLASS_SVM	python/liblinear/liblinear.py	/^ONECLASS_SVM = 21$/;"	v
OS	Makefile	/^OS = $(shell uname)$/;"	m
PACKAGE_DIR	python/setup.py	/^PACKAGE_DIR = "liblinear"$/;"	v
PACKAGE_NAME	python/setup.py	/^PACKAGE_NAME = "liblinear-official"$/;"	v
PRINT_STRING_FUN	python/liblinear/liblinear.py	/^PRINT_STRING_FUN = CFUNCTYPE(None, c_char_p)$/;"	v
RANLIB	blas/Makefile	/^RANLIB ?= ranlib$/;"	m
SHARED_LIB_FLAG	Makefile	/^	SHARED_LIB_FLAG = -dynamiclib -Wl,-install_name,liblinear.so.$(SHVER)$/;"	m
SHARED_LIB_FLAG	Makefile	/^	SHARED_LIB_FLAG = -shared -Wl,-soname,liblinear.so.$(SHVER)$/;"	m
SHVER	Makefile	/^SHVER = 5$/;"	m
SKIP_ELEMENT	svm-scale.c	100;"	d	file:
SKIP_TARGET	svm-scale.c	96;"	d	file:
Solve	linear.cpp	/^void Solver_MCSVM_CS::Solve(double *w)$/;"	f	class:Solver_MCSVM_CS
Solver_MCSVM_CS	linear.cpp	/^Solver_MCSVM_CS::Solver_MCSVM_CS(const problem *prob, int nr_class, double *weighted_C, double eps, int max_iter)$/;"	f	class:Solver_MCSVM_CS
Solver_MCSVM_CS	linear.cpp	/^class Solver_MCSVM_CS$/;"	c	file:
TRUE	blas/blas.h	19;"	d
VERSION	python/setup.py	/^VERSION = "2.47.0"$/;"	v
XTv	linear.cpp	/^void l2r_erm_fun::XTv(double *v, double *XTv)$/;"	f	class:l2r_erm_fun
Xv	linear.cpp	/^void l2r_erm_fun::Xv(double *v, double *Xv)$/;"	f	class:l2r_erm_fun
_LIBLINEAR_H	linear.h	2;"	d
_NEWTON_H	newton.h	2;"	d
__all__	python/liblinear/commonutil.py	/^__all__ = ['svm_read_problem', 'evaluations', 'csr_find_scale_param', 'csr_scale']$/;"	v
__all__	python/liblinear/liblinear.py	/^__all__ = ['liblinear', 'feature_node', 'gen_feature_nodearray', 'problem',$/;"	v
__all__	python/liblinear/liblinearutil.py	/^__all__ = ['load_model', 'save_model', 'train', 'predict'] + liblinear_all + common_all$/;"	v
__del__	python/liblinear/liblinear.py	/^    def __del__(self):$/;"	m	class:model	file:
__init__	python/liblinear/liblinear.py	/^    def __init__(self):$/;"	m	class:model
__init__	python/liblinear/liblinear.py	/^    def __init__(self, options = None):$/;"	m	class:parameter
__init__	python/liblinear/liblinear.py	/^    def __init__(self, y, x, bias = -1):$/;"	m	class:problem
__str__	python/liblinear/liblinear.py	/^    def __str__(self):$/;"	m	class:feature_node	file:
__str__	python/liblinear/liblinear.py	/^    def __str__(self):$/;"	m	class:parameter	file:
_cstr	python/liblinear/liblinearutil.py	/^    _cstr = lambda s: bytes(s, "utf-8")$/;"	v
_cstr	python/liblinear/liblinearutil.py	/^    _cstr = lambda s: s.encode("utf-8") if isinstance(s,unicode) else str(s)$/;"	v
_fields_	python/liblinear/liblinear.py	/^    _fields_ = genFields(_names, _types)$/;"	v	class:feature_node
_fields_	python/liblinear/liblinear.py	/^    _fields_ = genFields(_names, _types)$/;"	v	class:model
_fields_	python/liblinear/liblinear.py	/^    _fields_ = genFields(_names, _types)$/;"	v	class:parameter
_fields_	python/liblinear/liblinear.py	/^    _fields_ = genFields(_names, _types)$/;"	v	class:problem
_names	python/liblinear/liblinear.py	/^    _names = ["index", "value"]$/;"	v	class:feature_node
_names	python/liblinear/liblinear.py	/^    _names = ["l", "n", "y", "x", "bias"]$/;"	v	class:problem
_names	python/liblinear/liblinear.py	/^    _names = ["param", "nr_class", "nr_feature", "w", "label", "bias", "rho"]$/;"	v	class:model
_names	python/liblinear/liblinear.py	/^    _names = ["solver_type", "eps", "C", "nr_weight", "weight_label", "weight", "p", "nu", "init_sol", "regularize_bias"]$/;"	v	class:parameter
_types	python/liblinear/liblinear.py	/^    _types = [c_int, c_double, c_double, c_int, POINTER(c_int), POINTER(c_double), c_double, c_double, POINTER(c_double), c_int]$/;"	v	class:parameter
_types	python/liblinear/liblinear.py	/^    _types = [c_int, c_double]$/;"	v	class:feature_node
_types	python/liblinear/liblinear.py	/^    _types = [c_int, c_int, POINTER(c_double), POINTER(POINTER(feature_node)), c_double]$/;"	v	class:problem
_types	python/liblinear/liblinear.py	/^    _types = [parameter, c_int, c_int, POINTER(c_double), POINTER(c_int), c_double, c_double]$/;"	v	class:model
all	python/Makefile	/^all = lib$/;"	m
axpy	linear.cpp	/^	static void axpy(const double a, const feature_node *x, double *y)$/;"	f	class:sparse_operator
be_shrunk	linear.cpp	/^bool Solver_MCSVM_CS::be_shrunk(int i, int m, int yi, double alpha_i, double minG)$/;"	f	class:Solver_MCSVM_CS
bias	linear.h	/^	double bias;            \/* < 0 if no bias term *\/$/;"	m	struct:problem
bias	linear.h	/^	double bias;$/;"	m	struct:model
bias	matlab/train.c	/^double bias;$/;"	v
bias	train.c	/^double bias;$/;"	v
blasbool	blas/blas.h	/^typedef int blasbool;$/;"	t
calc_max_p	linear.cpp	/^static double calc_max_p(const problem *prob)$/;"	f	file:
calc_start_C	linear.cpp	/^static double calc_start_C(const problem *prob, const parameter *param)$/;"	f	file:
check_oneclass_model	linear.cpp	/^int check_oneclass_model(const struct model *model_)$/;"	f
check_parameter	linear.cpp	/^const char *check_parameter(const problem *prob, const parameter *param)$/;"	f
check_probability_model	linear.cpp	/^int check_probability_model(const struct model *model_)$/;"	f
check_regression_model	linear.cpp	/^int check_regression_model(const struct model *model_)$/;"	f
clean_up	svm-scale.c	/^int clean_up(FILE *fp_restore, FILE *fp, const char* msg)$/;"	f
clone	linear.cpp	/^template <class S, class T> static inline void clone(T*& dst, S* src, int n)$/;"	f	file:
col_format_flag	matlab/predict.c	/^int col_format_flag;$/;"	v
col_format_flag	matlab/train.c	/^int col_format_flag;$/;"	v
compare_double	linear.cpp	/^int compare_double(const void *a, const void *b)$/;"	f
compare_feature_node	linear.cpp	/^static int compare_feature_node(const void *a, const void *b)$/;"	f	file:
cpp_dir	python/setup.py	/^cpp_dir = "cpp-source"$/;"	v
create_cpp_source	python/setup.py	/^def create_cpp_source():$/;"	f
cross_validation	linear.cpp	/^void cross_validation(const problem *prob, const parameter *param, int nr_fold, double *target)$/;"	f
csr_find_scale_param	python/liblinear/commonutil.py	/^def csr_find_scale_param(x, lower=-1, upper=1):$/;"	f
csr_scale	python/liblinear/commonutil.py	/^def csr_scale(x, scale_param):$/;"	f
csr_to_problem	python/liblinear/liblinear.py	/^def csr_to_problem(x, prob):$/;"	f
csr_to_problem_jit	python/liblinear/liblinear.py	/^def csr_to_problem_jit(l, x_val, x_ind, x_rowptr, prob_val, prob_ind, prob_rowptr):$/;"	f
csr_to_problem_nojit	python/liblinear/liblinear.py	/^def csr_to_problem_nojit(l, x_val, x_ind, x_rowptr, prob_val, prob_ind, prob_rowptr):$/;"	f
daxpy_	blas/daxpy.c	/^int daxpy_(int *n, double *sa, double *sx, int *incx, double *sy,$/;"	f
dcomplex	blas/blas.h	/^typedef struct { double r, i; } dcomplex;$/;"	t	typeref:struct:__anon3
ddot_	blas/ddot.c	/^double ddot_(int *n, double *sx, int *incx, double *sy, int *incy)$/;"	f
default_print	newton.cpp	/^static void default_print(const char *buf)$/;"	f	file:
destroy_param	linear.cpp	/^void destroy_param(parameter* param)$/;"	f
dirname	python/liblinear/liblinear.py	/^    dirname = path.dirname(path.abspath(__file__))$/;"	v
dnrm2_	blas/dnrm2.c	/^double dnrm2_(int *n, double *x, int *incx)$/;"	f
do_cross_validation	matlab/train.c	/^double do_cross_validation()$/;"	f
do_cross_validation	train.c	/^void do_cross_validation()$/;"	f
do_find_parameters	matlab/train.c	/^void do_find_parameters(double *best_C, double *best_p, double *best_score)$/;"	f
do_find_parameters	train.c	/^void do_find_parameters()$/;"	f
do_predict	matlab/predict.c	/^void do_predict(int nlhs, mxArray *plhs[], const mxArray *prhs[], struct model *model_, const int predict_probability_flag)$/;"	f
do_predict	predict.c	/^void do_predict(FILE *input, FILE *output)$/;"	f
dot	linear.cpp	/^	static double dot(const double *s, const feature_node *x)$/;"	f	class:sparse_operator
dscal_	blas/dscal.c	/^int dscal_(int *n, double *sa, double *sx, int *incx)$/;"	f
dynamic_lib_name	python/liblinear/liblinear.py	/^    dynamic_lib_name = 'clib.cp*'$/;"	v
dynamic_lib_name	python/setup.py	/^dynamic_lib_name = "clib"$/;"	v
eps	linear.cpp	/^		double eps;$/;"	m	class:Solver_MCSVM_CS	file:
eps	linear.h	/^	double eps;             \/* stopping tolerance *\/$/;"	m	struct:parameter
eps	newton.h	/^	double eps;$/;"	m	class:NEWTON
eps_cg	newton.h	/^	double eps_cg;$/;"	m	class:NEWTON
evaluations	python/liblinear/commonutil.py	/^def evaluations(ty, pv, useScipy = True):$/;"	f
evaluations_scipy	python/liblinear/commonutil.py	/^def evaluations_scipy(ty, pv):$/;"	f
exit_input_error	predict.c	/^void exit_input_error(int line_num)$/;"	f
exit_input_error	train.c	/^void exit_input_error(int line_num)$/;"	f
exit_with_help	matlab/libsvmread.c	/^void exit_with_help()$/;"	f
exit_with_help	matlab/libsvmwrite.c	/^void exit_with_help()$/;"	f
exit_with_help	matlab/predict.c	/^void exit_with_help()$/;"	f
exit_with_help	matlab/train.c	/^void exit_with_help()$/;"	f
exit_with_help	predict.c	/^void exit_with_help()$/;"	f
exit_with_help	svm-scale.c	/^void exit_with_help()$/;"	f
exit_with_help	train.c	/^void exit_with_help()$/;"	f
fake_answer	matlab/libsvmread.c	/^static void fake_answer(int nlhs, mxArray *plhs[])$/;"	f	file:
fake_answer	matlab/libsvmwrite.c	/^static void fake_answer(int nlhs, mxArray *plhs[])$/;"	f	file:
fake_answer	matlab/predict.c	/^static void fake_answer(int nlhs, mxArray *plhs[])$/;"	f	file:
fake_answer	matlab/train.c	/^static void fake_answer(int nlhs, mxArray *plhs[])$/;"	f	file:
fcomplex	blas/blas.h	/^typedef struct { float r, i; } fcomplex;$/;"	t	typeref:struct:__anon2
feature_max	svm-scale.c	/^double *feature_max;$/;"	v
feature_min	svm-scale.c	/^double *feature_min;$/;"	v
feature_node	linear.h	/^struct feature_node$/;"	s
feature_node	python/liblinear/liblinear.py	/^class feature_node(Structure):$/;"	c
field_names	matlab/linear_model_matlab.c	/^static const char *field_names[] = {$/;"	v	file:
filename_size	matlab/libsvmread.c	191;"	d	file:
fillprototype	python/liblinear/liblinear.py	/^def fillprototype(f, restype, argtypes):$/;"	f
find_parameter_C	linear.cpp	/^static void find_parameter_C(const problem *prob, parameter *param_tmp, double start_C, double max_C, double *best_C, double *best_score, const int *fold_start, const int *perm, const problem *subprob, int nr_fold)$/;"	f	file:
find_parameters	linear.cpp	/^void find_parameters(const problem *prob, const parameter *param, int nr_fold, double start_C, double start_p, double *best_C, double *best_p, double *best_score)$/;"	f
flag_C_specified	matlab/train.c	/^int flag_C_specified;$/;"	v
flag_C_specified	train.c	/^int flag_C_specified;$/;"	v
flag_cross_validation	matlab/train.c	/^int flag_cross_validation;$/;"	v
flag_cross_validation	train.c	/^int flag_cross_validation;$/;"	v
flag_find_parameters	matlab/train.c	/^int flag_find_parameters;$/;"	v
flag_find_parameters	train.c	/^int flag_find_parameters;$/;"	v
flag_p_specified	matlab/train.c	/^int flag_p_specified;$/;"	v
flag_p_specified	train.c	/^int flag_p_specified;$/;"	v
flag_predict_probability	predict.c	/^int flag_predict_probability=0;$/;"	v
flag_solver_specified	matlab/train.c	/^int flag_solver_specified;$/;"	v
flag_solver_specified	train.c	/^int flag_solver_specified;$/;"	v
free_and_destroy_model	linear.cpp	/^void free_and_destroy_model(struct model **model_ptr_ptr)$/;"	f
free_model_content	linear.cpp	/^void free_model_content(struct model *model_ptr)$/;"	f
fun	linear.cpp	/^double l2r_erm_fun::fun(double *w)$/;"	f	class:l2r_erm_fun
fun_obj	newton.h	/^	function *fun_obj;$/;"	m	class:NEWTON
function	newton.h	/^class function$/;"	c
genFields	python/liblinear/liblinear.py	/^def genFields(names, types):$/;"	f
gen_feature_nodearray	python/liblinear/liblinear.py	/^def gen_feature_nodearray(xi, feature_max=None):$/;"	f
get_decfun	python/liblinear/liblinear.py	/^    def get_decfun(self, label_idx=0):$/;"	m	class:model
get_decfun_bias	linear.cpp	/^double get_decfun_bias(const struct model *model_, int label_idx)$/;"	f
get_decfun_bias	python/liblinear/liblinear.py	/^    def get_decfun_bias(self, label_idx=0):$/;"	m	class:model
get_decfun_coef	linear.cpp	/^double get_decfun_coef(const struct model *model_, int feat_idx, int label_idx)$/;"	f
get_decfun_coef	python/liblinear/liblinear.py	/^    def get_decfun_coef(self, feat_idx, label_idx=0):$/;"	m	class:model
get_decfun_rho	linear.cpp	/^double get_decfun_rho(const struct model *model_)$/;"	f
get_decfun_rho	python/liblinear/liblinear.py	/^    def get_decfun_rho(self):$/;"	m	class:model
get_diag_preconditioner	linear.cpp	/^void l2r_l2_svc_fun::get_diag_preconditioner(double *M)$/;"	f	class:l2r_l2_svc_fun
get_diag_preconditioner	linear.cpp	/^void l2r_lr_fun::get_diag_preconditioner(double *M)$/;"	f	class:l2r_lr_fun
get_labels	linear.cpp	/^void get_labels(const model *model_, int* label)$/;"	f
get_labels	python/liblinear/liblinear.py	/^    def get_labels(self):$/;"	m	class:model
get_nr_class	linear.cpp	/^int get_nr_class(const model *model_)$/;"	f
get_nr_class	python/liblinear/liblinear.py	/^    def get_nr_class(self):$/;"	m	class:model
get_nr_feature	linear.cpp	/^int get_nr_feature(const model *model_)$/;"	f
get_nr_feature	python/liblinear/liblinear.py	/^    def get_nr_feature(self):$/;"	m	class:model
get_nr_variable	linear.cpp	/^int l2r_erm_fun::get_nr_variable(void)$/;"	f	class:l2r_erm_fun
get_w_value	linear.cpp	/^static inline double get_w_value(const struct model *model_, int idx, int label_idx)$/;"	f	file:
grad	linear.cpp	/^void l2r_l2_svc_fun::grad(double *w, double *g)$/;"	f	class:l2r_l2_svc_fun
grad	linear.cpp	/^void l2r_l2_svr_fun::grad(double *w, double *g)$/;"	f	class:l2r_l2_svr_fun
grad	linear.cpp	/^void l2r_lr_fun::grad(double *w, double *g)$/;"	f	class:l2r_lr_fun
group_classes	linear.cpp	/^static void group_classes(const problem *prob, int *nr_class_ret, int **label_ret, int **start_ret, int **count_ret, int *perm)$/;"	f	file:
headers	python/setup.py	/^headers = [$/;"	v
i	blas/blas.h	/^typedef struct { double r, i; } dcomplex;$/;"	m	struct:__anon3
i	blas/blas.h	/^typedef struct { float r, i; } fcomplex;$/;"	m	struct:__anon2
index	linear.h	/^	int index;$/;"	m	struct:feature_node
info	linear.cpp	/^static void info(const char *fmt,...) {}$/;"	f	file:
info	linear.cpp	/^static void info(const char *fmt,...)$/;"	f	file:
info	matlab/predict.c	/^int (*info)(const char *fmt,...);$/;"	v
info	newton.cpp	/^void NEWTON::info(const char *fmt,...)$/;"	f	class:NEWTON
info	predict.c	/^static int (*info)(const char *fmt,...) = &printf;$/;"	v	file:
info	python/liblinear/liblinearutil.py	/^    def info(s):$/;"	f	function:predict
init_sol	linear.h	/^	double *init_sol;$/;"	m	struct:parameter
is_oneclass_model	python/liblinear/liblinear.py	/^    def is_oneclass_model(self):$/;"	m	class:model
is_probability_model	python/liblinear/liblinear.py	/^    def is_probability_model(self):$/;"	m	class:model
is_regression_model	python/liblinear/liblinear.py	/^    def is_regression_model(self):$/;"	m	class:model
jit	python/liblinear/liblinear.py	/^    jit = lambda x: x$/;"	v
jit_enabled	python/liblinear/liblinear.py	/^    jit_enabled = False$/;"	v
jit_enabled	python/liblinear/liblinear.py	/^    jit_enabled = True$/;"	v
kwargs_for_extension	python/setup.py	/^kwargs_for_extension = {$/;"	v
l	linear.cpp	/^		int w_size, l;$/;"	m	class:Solver_MCSVM_CS	file:
l	linear.h	/^	int l, n;$/;"	m	struct:problem
l2r_erm_fun	linear.cpp	/^class l2r_erm_fun: public function$/;"	c	file:
l2r_erm_fun	linear.cpp	/^l2r_erm_fun::l2r_erm_fun(const problem *prob, const parameter *param, double *C)$/;"	f	class:l2r_erm_fun
l2r_l2_svc_fun	linear.cpp	/^class l2r_l2_svc_fun: public l2r_erm_fun$/;"	c	file:
l2r_l2_svc_fun	linear.cpp	/^l2r_l2_svc_fun::l2r_l2_svc_fun(const problem *prob, const parameter *param, double *C):$/;"	f	class:l2r_l2_svc_fun
l2r_l2_svr_fun	linear.cpp	/^class l2r_l2_svr_fun: public l2r_l2_svc_fun$/;"	c	file:
l2r_l2_svr_fun	linear.cpp	/^l2r_l2_svr_fun::l2r_l2_svr_fun(const problem *prob, const parameter *param, double *C):$/;"	f	class:l2r_l2_svr_fun
l2r_lr_fun	linear.cpp	/^class l2r_lr_fun: public l2r_erm_fun$/;"	c	file:
l2r_lr_fun	linear.cpp	/^l2r_lr_fun::l2r_lr_fun(const problem *prob, const parameter *param, double *C):$/;"	f	class:l2r_lr_fun
label	linear.h	/^	int *label;             \/* label of each class *\/$/;"	m	struct:model
liblinear	python/liblinear/liblinear.py	/^            liblinear = CDLL(find_library('liblinear'))$/;"	v
liblinear	python/liblinear/liblinear.py	/^            liblinear = CDLL(find_library('linear'))$/;"	v
liblinear	python/liblinear/liblinear.py	/^            liblinear = CDLL(path.join(dirname, '..\/..\/liblinear.so.5'))$/;"	v
liblinear	python/liblinear/liblinear.py	/^            liblinear = CDLL(path.join(dirname, r'..\\..\\windows\\liblinear.dll'))$/;"	v
liblinear	python/liblinear/liblinear.py	/^    liblinear = CDLL(path_to_so)$/;"	v
liblinear_print_string	linear.cpp	/^static void (*liblinear_print_string) (const char *) = &print_string_stdout;$/;"	v	file:
liblinear_version	linear.cpp	/^int liblinear_version = LIBLINEAR_VERSION;$/;"	v
libsvmwrite	matlab/libsvmwrite.c	/^void libsvmwrite(const char *filename, const mxArray *label_vec, const mxArray *instance_mat)$/;"	f
license_file	python/setup.py	/^license_file = "LICENSE"$/;"	v
license_name	python/setup.py	/^license_name = "BSD-3-Clause"$/;"	v
license_source	python/setup.py	/^license_source = path.join("..", "COPYRIGHT")$/;"	v
line	matlab/libsvmread.c	/^static char *line;$/;"	v	file:
line	predict.c	/^static char *line = NULL;$/;"	v	file:
line	svm-scale.c	/^char *line = NULL;$/;"	v
line	train.c	/^static char *line = NULL;$/;"	v	file:
linesearch_and_update	linear.cpp	/^double l2r_erm_fun::linesearch_and_update(double *w, double *s, double *f, double *g, double alpha)$/;"	f	class:l2r_erm_fun
linesearch_and_update	newton.cpp	/^double function::linesearch_and_update(double *w, double *s, double *f, double *g, double alpha)$/;"	f	class:function
load_model	linear.cpp	/^struct model *load_model(const char *model_file_name)$/;"	f
load_model	python/liblinear/liblinearutil.py	/^def load_model(model_file_name):$/;"	f
lower	svm-scale.c	/^double lower=-1.0,upper=1.0,y_lower,y_upper;$/;"	v
main	predict.c	/^int main(int argc, char **argv)$/;"	f
main	python/setup.py	/^def main():$/;"	f
main	svm-scale.c	/^int main(int argc,char **argv)$/;"	f
main	train.c	/^int main(int argc, char **argv)$/;"	f
make	matlab/make.m	/^function make()$/;"	f
matlab_matrix_to_model	matlab/linear_model_matlab.c	/^const char *matlab_matrix_to_model(struct model *model_, const mxArray *matlab_struct)$/;"	f
max	linear.cpp	/^template <class T> static inline T max(T x,T y) { return (x>y)?x:y; }$/;"	f	file:
max	matlab/libsvmread.c	15;"	d	file:
max	newton.cpp	/^template <class T> static inline T max(T x,T y) { return (x>y)?x:y; }$/;"	f	file:
max	svm-scale.c	34;"	d	file:
max_index	svm-scale.c	/^int max_index;$/;"	v
max_iter	linear.cpp	/^		int max_iter;$/;"	m	class:Solver_MCSVM_CS	file:
max_iter	newton.h	/^	int max_iter;$/;"	m	class:NEWTON
max_line_len	matlab/libsvmread.c	/^static int max_line_len;$/;"	v	file:
max_line_len	predict.c	/^static int max_line_len;$/;"	v	file:
max_line_len	svm-scale.c	/^int max_line_len = 1024;$/;"	v
max_line_len	train.c	/^static int max_line_len;$/;"	v	file:
max_nr_attr	predict.c	/^int max_nr_attr = 64;$/;"	v
mexFunction	matlab/libsvmread.c	/^void mexFunction( int nlhs, mxArray *plhs[],$/;"	f
mexFunction	matlab/libsvmwrite.c	/^void mexFunction( int nlhs, mxArray *plhs[],$/;"	f
mexFunction	matlab/predict.c	/^void mexFunction( int nlhs, mxArray *plhs[],$/;"	f
mexFunction	matlab/train.c	/^void mexFunction( int nlhs, mxArray *plhs[],$/;"	f
min	linear.cpp	/^template <class T> static inline T min(T x,T y) { return (x<y)?x:y; }$/;"	f	file:
min	matlab/libsvmread.c	18;"	d	file:
min	newton.cpp	/^template <class T> static inline T min(T x,T y) { return (x<y)?x:y; }$/;"	f	file:
min	svm-scale.c	35;"	d	file:
min_index	svm-scale.c	/^int min_index;$/;"	v
model	linear.h	/^struct model$/;"	s
model	python/liblinear/liblinear.py	/^class model(Structure):$/;"	c
model_	matlab/train.c	/^struct model *model_;$/;"	v	typeref:struct:model
model_	predict.c	/^struct model* model_;$/;"	v	typeref:struct:model
model_	train.c	/^struct model* model_;$/;"	v	typeref:struct:model
model_to_matlab_structure	matlab/linear_model_matlab.c	/^const char *model_to_matlab_structure(mxArray *plhs[], struct model *model_)$/;"	f
mwIndex	matlab/libsvmread.c	/^typedef int mwIndex;$/;"	t	file:
mwIndex	matlab/libsvmwrite.c	/^typedef int mwIndex;$/;"	t	file:
mwIndex	matlab/linear_model_matlab.c	/^typedef int mwIndex;$/;"	t	file:
mwIndex	matlab/predict.c	/^typedef int mwIndex;$/;"	t	file:
mwIndex	matlab/train.c	/^typedef int mwIndex;$/;"	t	file:
n	linear.h	/^	int l, n;$/;"	m	struct:problem
new_num_nonzeros	svm-scale.c	/^long int new_num_nonzeros = 0;$/;"	v
newton	newton.cpp	/^void NEWTON::newton(double *w)$/;"	f	class:NEWTON
newton_print_string	newton.h	/^	void (*newton_print_string)(const char *buf);$/;"	m	class:NEWTON
nr_class	linear.cpp	/^		int nr_class;$/;"	m	class:Solver_MCSVM_CS	file:
nr_class	linear.h	/^	int nr_class;           \/* number of classes *\/$/;"	m	struct:model
nr_feature	linear.h	/^	int nr_feature;$/;"	m	struct:model
nr_fold	matlab/train.c	/^int nr_fold;$/;"	v
nr_fold	train.c	/^int nr_fold;$/;"	v
nr_weight	linear.h	/^	int nr_weight;$/;"	m	struct:parameter
nrm2_sq	linear.cpp	/^	static double nrm2_sq(const feature_node *x)$/;"	f	class:sparse_operator
nu	linear.h	/^	double nu;$/;"	m	struct:parameter
num_nonzeros	svm-scale.c	/^long int num_nonzeros = 0;$/;"	v
output	svm-scale.c	/^void output(int index, double value)$/;"	f
output_target	svm-scale.c	/^void output_target(double value)$/;"	f
p	linear.cpp	/^	double p;$/;"	m	class:l2r_l2_svr_fun	file:
p	linear.h	/^	double p;$/;"	m	struct:parameter
param	linear.h	/^	struct parameter param;$/;"	m	struct:model	typeref:struct:model::parameter
param	matlab/train.c	/^struct parameter param;		\/\/ set by parse_command_line$/;"	v	typeref:struct:parameter
param	train.c	/^struct parameter param;$/;"	v	typeref:struct:parameter
parameter	linear.h	/^struct parameter$/;"	s
parameter	python/liblinear/liblinear.py	/^class parameter(Structure):$/;"	c
parse_command_line	matlab/train.c	/^int parse_command_line(int nrhs, const mxArray *prhs[], char *model_file_name)$/;"	f
parse_command_line	train.c	/^void parse_command_line(int argc, char **argv, char *input_file_name, char *model_file_name)$/;"	f
parse_options	python/liblinear/liblinear.py	/^    def parse_options(self, options):$/;"	m	class:parameter
partition	linear.cpp	/^static int partition(feature_node *nodes, int low, int high)$/;"	f	file:
path_to_so	python/liblinear/liblinear.py	/^    path_to_so = glob(path.join(dirname, dynamic_lib_name))[0]$/;"	v
pcg	newton.cpp	/^int NEWTON::pcg(double *g, double *M, double *s, double *r)$/;"	f	class:NEWTON
predict	linear.cpp	/^double predict(const model *model_, const feature_node *x)$/;"	f
predict	python/liblinear/liblinearutil.py	/^def predict(y, x, m, options=""):$/;"	f
predict_probability	linear.cpp	/^double predict_probability(const struct model *model_, const struct feature_node *x, double* prob_estimates)$/;"	f
predict_values	linear.cpp	/^double predict_values(const struct model *model_, const struct feature_node *x, double *dec_values)$/;"	f
print_null	linear.cpp	/^static void print_null(const char *s) {}$/;"	f	file:
print_null	matlab/predict.c	/^int print_null(const char *s,...) {return 0;}$/;"	f
print_null	matlab/train.c	/^void print_null(const char *s) {}$/;"	f
print_null	predict.c	/^int print_null(const char *s,...) {return 0;}$/;"	f
print_null	python/liblinear/liblinear.py	/^def print_null(s):$/;"	f
print_null	train.c	/^void print_null(const char *s) {}$/;"	f
print_string_matlab	matlab/train.c	/^void print_string_matlab(const char *s) {mexPrintf(s);}$/;"	f
print_string_stdout	linear.cpp	/^static void print_string_stdout(const char *s)$/;"	f	file:
prob	linear.cpp	/^		const problem *prob;$/;"	m	class:Solver_MCSVM_CS	file:
prob	linear.cpp	/^	const problem *prob;$/;"	m	class:l2r_erm_fun	file:
prob	matlab/train.c	/^struct problem prob;		\/\/ set by read_problem$/;"	v	typeref:struct:problem
prob	train.c	/^struct problem prob;$/;"	v	typeref:struct:problem
problem	linear.h	/^struct problem$/;"	s
problem	python/liblinear/liblinear.py	/^class problem(Structure):$/;"	c
quick_select_min_k	linear.cpp	/^static void quick_select_min_k(feature_node *nodes, int low, int high, int k)$/;"	f	file:
r	blas/blas.h	/^typedef struct { double r, i; } dcomplex;$/;"	m	struct:__anon3
r	blas/blas.h	/^typedef struct { float r, i; } fcomplex;$/;"	m	struct:__anon2
range	python/liblinear/liblinear.py	/^    range = xrange$/;"	v
range	python/liblinear/liblinearutil.py	/^    range = xrange$/;"	v
read_problem	matlab/libsvmread.c	/^void read_problem(const char *filename, int nlhs, mxArray *plhs[])$/;"	f
read_problem	train.c	/^void read_problem(const char *filename)$/;"	f
read_problem_sparse	matlab/train.c	/^int read_problem_sparse(const mxArray *label_vec, const mxArray *instance_mat)$/;"	f
read_sparse_instance	matlab/predict.c	/^void read_sparse_instance(const mxArray *prhs, int index, struct feature_node *x, int feature_number, double bias)$/;"	f
readline	matlab/libsvmread.c	/^static char* readline(FILE *input)$/;"	f	file:
readline	predict.c	/^static char* readline(FILE *input)$/;"	f	file:
readline	svm-scale.c	/^char* readline(FILE *input)$/;"	f
readline	train.c	/^static char* readline(FILE *input)$/;"	f	file:
regularize_bias	linear.cpp	/^	int regularize_bias;$/;"	m	class:l2r_erm_fun	file:
regularize_bias	linear.h	/^	int regularize_bias;$/;"	m	struct:parameter
rho	linear.h	/^	double rho;             \/* one-class SVM only *\/$/;"	m	struct:model
run	python/setup.py	/^    def run(self):$/;"	m	class:CleanCommand
save_model	linear.cpp	/^int save_model(const char *model_file_name, const struct model *model_)$/;"	f
save_model	python/liblinear/liblinearutil.py	/^def save_model(model_file_name, model):$/;"	f
schar	linear.cpp	/^typedef signed char schar;$/;"	t	file:
scipy	python/liblinear/commonutil.py	/^    scipy = None$/;"	v
scipy	python/liblinear/liblinear.py	/^    scipy = None$/;"	v
scipy	python/liblinear/liblinearutil.py	/^    scipy = None$/;"	v
set_bias	python/liblinear/liblinear.py	/^    def set_bias(self, bias):$/;"	m	class:problem
set_print_string	newton.cpp	/^void NEWTON::set_print_string(void (*print_string) (const char *buf))$/;"	f	class:NEWTON
set_print_string_function	linear.cpp	/^void set_print_string_function(void (*print_func)(const char*))$/;"	f
set_to_default_values	python/liblinear/liblinear.py	/^    def set_to_default_values(self):$/;"	m	class:parameter
sizeI	linear.cpp	/^	int sizeI;$/;"	m	class:l2r_l2_svc_fun	file:
solve_l1r_l2_svc	linear.cpp	/^static int solve_l1r_l2_svc(const problem *prob_col, const parameter* param, double *w, double Cp, double Cn, double eps)$/;"	f	file:
solve_l1r_lr	linear.cpp	/^static int solve_l1r_lr(const problem *prob_col, const parameter *param, double *w, double Cp, double Cn, double eps)$/;"	f	file:
solve_l2r_l1l2_svc	linear.cpp	/^static int solve_l2r_l1l2_svc(const problem *prob, const parameter *param, double *w, double Cp, double Cn, int max_iter=300)$/;"	f	file:
solve_l2r_l1l2_svr	linear.cpp	/^static int solve_l2r_l1l2_svr(const problem *prob, const parameter *param, double *w, int max_iter=300)$/;"	f	file:
solve_l2r_lr_dual	linear.cpp	/^static int solve_l2r_lr_dual(const problem *prob, const parameter *param, double *w, double Cp, double Cn, int max_iter=300)$/;"	f	file:
solve_oneclass_svm	linear.cpp	/^static int solve_oneclass_svm(const problem *prob, const parameter *param, double *w, double *rho)$/;"	f	file:
solve_sub_problem	linear.cpp	/^void Solver_MCSVM_CS::solve_sub_problem(double A_i, int yi, double C_yi, int active_i, double *alpha_new)$/;"	f	class:Solver_MCSVM_CS
solver_type	linear.h	/^	int solver_type;$/;"	m	struct:parameter
solver_type_table	linear.cpp	/^static const char *solver_type_table[]=$/;"	v	file:
source_codes	python/setup.py	/^source_codes = [$/;"	v
sparse_dot	linear.cpp	/^	static double sparse_dot(const feature_node *x1, const feature_node *x2)$/;"	f	class:sparse_operator
sparse_operator	linear.cpp	/^class sparse_operator$/;"	c	file:
subXTv	linear.cpp	/^void l2r_l2_svc_fun::subXTv(double *v, double *XTv)$/;"	f	class:l2r_l2_svc_fun
svm_read_problem	python/liblinear/commonutil.py	/^def svm_read_problem(data_file_name, return_scipy=False):$/;"	f
swap	linear.cpp	/^template <class T> static inline void swap(T& x, T& y) { T t=x; x=y; y=t; }$/;"	f	file:
tmp	linear.cpp	/^	double *tmp; \/\/ a working array$/;"	m	class:l2r_erm_fun	file:
toPyModel	python/liblinear/liblinear.py	/^def toPyModel(model_ptr):$/;"	f
train	linear.cpp	/^model* train(const problem *prob, const parameter *param)$/;"	f
train	python/liblinear/liblinearutil.py	/^def train(arg1, arg2=None, arg3=None):$/;"	f
train_one	linear.cpp	/^static void train_one(const problem *prob, const parameter *param, double *w, double Cp, double Cn)$/;"	f	file:
transpose	linear.cpp	/^static void transpose(const problem *prob, feature_node **x_space_ret, problem *prob_col)$/;"	f	file:
upper	svm-scale.c	/^double lower=-1.0,upper=1.0,y_lower,y_upper;$/;"	v
value	linear.h	/^	double value;$/;"	m	struct:feature_node
w	linear.h	/^	double *w;$/;"	m	struct:model
wTw	linear.cpp	/^	double wTw;$/;"	m	class:l2r_erm_fun	file:
w_size	linear.cpp	/^		int w_size, l;$/;"	m	class:Solver_MCSVM_CS	file:
weight	linear.h	/^	double* weight;$/;"	m	struct:parameter
weight_label	linear.h	/^	int *weight_label;$/;"	m	struct:parameter
wx	linear.cpp	/^	double *wx;$/;"	m	class:l2r_erm_fun	file:
x	linear.h	/^	struct feature_node **x;$/;"	m	struct:problem	typeref:struct:problem::feature_node
x	predict.c	/^struct feature_node *x;$/;"	v	typeref:struct:feature_node
x_space	matlab/train.c	/^struct feature_node *x_space;$/;"	v	typeref:struct:feature_node
x_space	train.c	/^struct feature_node *x_space;$/;"	v	typeref:struct:feature_node
y	linear.h	/^	double *y;$/;"	m	struct:problem
y_lower	svm-scale.c	/^double lower=-1.0,upper=1.0,y_lower,y_upper;$/;"	v
y_max	svm-scale.c	/^double y_max = -DBL_MAX;$/;"	v
y_min	svm-scale.c	/^double y_min = DBL_MAX;$/;"	v
y_scaling	svm-scale.c	/^int y_scaling = 0;$/;"	v
y_upper	svm-scale.c	/^double lower=-1.0,upper=1.0,y_lower,y_upper;$/;"	v
~NEWTON	newton.cpp	/^NEWTON::~NEWTON()$/;"	f	class:NEWTON
~Solver_MCSVM_CS	linear.cpp	/^Solver_MCSVM_CS::~Solver_MCSVM_CS()$/;"	f	class:Solver_MCSVM_CS
~function	newton.h	/^	virtual ~function(void){}$/;"	f	class:function
~l2r_erm_fun	linear.cpp	/^l2r_erm_fun::~l2r_erm_fun()$/;"	f	class:l2r_erm_fun
~l2r_l2_svc_fun	linear.cpp	/^l2r_l2_svc_fun::~l2r_l2_svc_fun()$/;"	f	class:l2r_l2_svc_fun
~l2r_lr_fun	linear.cpp	/^l2r_lr_fun::~l2r_lr_fun()$/;"	f	class:l2r_lr_fun
